/** Generated by uRequire v0.6.9 - template: 'combined' */
/** Combined template optimized with RequireJS/r.js v2.1.9 & almond. */
(function (global, window){
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;

  var __nodeRequire = (__isNode ? require :
      function(dep){
        throw new Error("uRequire detected missing dependency: '" + dep + "' - in a non-nodejs runtime. All it's binding variables were 'undefined'.")
      });
var bundleFactory = function($) {
/**
 * almond 0.2.7 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('utilities/animframe',['require','exports','module'],function (require, exports, module) {
  

module.exports = function () {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
    return window.setTimeout(callback, 1000 / 60);
  };
}();

return module.exports;

});
define('game',['require', 'exports', 'module', './utilities/animframe'], function (require, exports, module) {
  

var Game, requestAnimFrame, __bind = function (fn, me) {
    return function () {
      return fn.apply(me, arguments);
    };
  };
requestAnimFrame = require("./utilities/animframe");
module.exports = Game = function () {
  function Game(wrapper, debug) {
    this.wrapper = wrapper;
    this.debug = debug != null ? debug : false;
    this.tick = __bind(this.tick, this);
    this.canvas = this.wrapper.find("canvas").get(0);
    this.setSize(this.wrapper.width(), this.wrapper.height());
    this.context = this.canvas.getContext("2d");
    this.running = false;
    if (this.debug) {
      this.setupStats();
    }
  }
  Game.prototype.clearDisplay = function () {
    return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };
  Game.prototype.setSize = function (width, height) {
    this.canvas.width = width;
    return this.canvas.height = height;
  };
  Game.prototype.getWidth = function () {
    return this.canvas.width;
  };
  Game.prototype.getHeight = function () {
    return this.canvas.height;
  };
  Game.prototype.getWrapper = function () {
    return this.wrapper;
  };
  Game.prototype.run = function () {
    this.running = true;
    this.lastTick = new Date();
    return requestAnimFrame(this.tick);
  };
  Game.prototype.stop = function () {
    return this.running = false;
  };
  Game.prototype.update = function (delta) {
  };
  Game.prototype.tick = function () {
    var delta, _ref, _ref1;
    delta = (Date.now() - this.lastTick) / 1000;
    this.lastTick = Date.now();
    this.update(delta);
    if ((_ref = this.screen) != null) {
      _ref.update(delta);
    }
    this.clearDisplay();
    if ((_ref1 = this.screen) != null) {
      _ref1.draw(this.context);
    }
    if (this.running) {
      return requestAnimFrame(this.tick);
    }
  };
  return Game;
}();

return module.exports;

});
define('screen',['require','exports','module'],function (require, exports, module) {
  

var Screen;
module.exports = Screen = function () {
  function Screen(game) {
    this.game = game;
    return;
  }
  Screen.prototype.update = function (delta) {
  };
  Screen.prototype.draw = function (context) {
  };
  return Screen;
}();

return module.exports;

});
define('math/vector2',['require','exports','module'],function (require, exports, module) {
  

var Vector2;
module.exports = Vector2 = function () {
  function Vector2(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
    return;
  }
  Vector2.prototype.set = function (x, y) {
    var otherV2;
    if (x instanceof Vector2) {
      otherV2 = x;
      this.x = otherV2.x;
      this.y = otherV2.y;
    } else {
      this.x = x;
      this.y = y;
    }
    return this;
  };
  Vector2.prototype.clone = function () {
    return new Vector2(this.x, this.y);
  };
  Vector2.prototype.floor = function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  };
  Vector2.prototype.round = function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  };
  Vector2.prototype.substract = function (x, y) {
    var v2;
    if (x instanceof Vector2) {
      v2 = x;
      x = v2.getX();
      y = v2.getY();
    } else if (x != null && y == null) {
      y = x;
    }
    this.x = this.x - x;
    this.y = this.y - y;
    return this;
  };
  Vector2.prototype.add = function (x, y) {
    var v2;
    if (x instanceof Vector2) {
      v2 = x;
      x = v2.getX();
      y = v2.getY();
    } else if (x != null && y == null) {
      y = x;
    }
    this.x = this.x + x;
    this.y = this.y + y;
    return this;
  };
  Vector2.prototype.divideBy = function (x, y) {
    var v2;
    if (x instanceof Vector2) {
      v2 = x;
      x = v2.getX();
      y = v2.getY();
    } else if (x != null && y == null) {
      y = x;
    }
    this.x = this.x / x;
    this.y = this.y / y;
    return this;
  };
  Vector2.prototype.multiply = function (x, y) {
    var v2;
    if (x instanceof Vector2) {
      v2 = x;
      x = v2.getX();
      y = v2.getY();
    } else if (x != null && y == null) {
      y = x;
    }
    this.x = this.x * x;
    this.y = this.y * y;
    return this;
  };
  Vector2.prototype.getX = function () {
    return this.x;
  };
  Vector2.prototype.getY = function () {
    return this.y;
  };
  Vector2.prototype.setX = function (x) {
    return this.x = x;
  };
  Vector2.prototype.setY = function (y) {
    return this.y = y;
  };
  return Vector2;
}();

return module.exports;

});
define('math/rectangle',['require', 'exports', 'module', './vector2'], function (require, exports, module) {
  

var Rectangle, Vector2;
Vector2 = require("./vector2");
module.exports = Rectangle = function () {
  function Rectangle(x, y, width, height) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    this.width = width != null ? width : 0;
    this.height = height != null ? height : 0;
    this.position = new Vector2(x, y);
  }
  Rectangle.prototype.setPosition = function () {
    return this.position.set.call(this, arguments);
  };
  Rectangle.prototype.setSize = function (width, height) {
    this.width = width;
    return this.height = height;
  };
  Rectangle.prototype.getWidth = function () {
    return this.width;
  };
  Rectangle.prototype.getHeight = function () {
    return this.height;
  };
  return Rectangle;
}();

return module.exports;

});
define('node',['require', 'exports', 'module', './math/vector2', './math/rectangle'], function (require, exports, module) {
  

var Node, Rectangle, Vector2;
Vector2 = require("./math/vector2");
Rectangle = require("./math/rectangle");
module.exports = Node = function () {
  function Node(game) {
    this.game = game;
    this.origin = new Vector2();
    this.position = new Vector2();
    this.scale = new Vector2(1, 1);
    this.rect = new Rectangle();
  }
  Node.prototype.getPosition = function () {
    return this.position;
  };
  Node.prototype.setPosition = function (x, y) {
    return this.position.set(x, y);
  };
  Node.prototype.getX = function () {
    return this.position.getX();
  };
  Node.prototype.setX = function (x) {
    return this.position.setX(x);
  };
  Node.prototype.getY = function () {
    return this.position.getY();
  };
  Node.prototype.setY = function (y) {
    return this.position.setY(y);
  };
  Node.prototype.getScale = function () {
    return this.scale;
  };
  Node.prototype.setScale = function (x, y) {
    return this.scale.set(x, y);
  };
  Node.prototype.getScaleX = function () {
    return this.scale.getX();
  };
  Node.prototype.setScaleX = function (x) {
    return this.scale.setX(x);
  };
  Node.prototype.getScaleY = function () {
    return this.scale.getY();
  };
  Node.prototype.setScaleY = function (y) {
    return this.scale.setY(y);
  };
  Node.prototype.getOrigin = function () {
    return this.origin;
  };
  Node.prototype.setOrigin = function (x, y) {
    return this.origin.set(x, y);
  };
  Node.prototype.getOriginX = function () {
    return this.scale.getX();
  };
  Node.prototype.setOriginX = function (x) {
    return this.origin.setX(x);
  };
  Node.prototype.getOriginY = function () {
    return this.origin.getY();
  };
  Node.prototype.setOriginY = function (y) {
    return this.origin.setY(y);
  };
  Node.prototype.getSize = function () {
    return this.rect.getSize();
  };
  Node.prototype.setSize = function (width, height) {
    return this.rect.setSize(width, height);
  };
  Node.prototype.getWidth = function () {
    return this.rect.getWidth();
  };
  Node.prototype.getHeight = function () {
    return this.rect.getHeight();
  };
  return Node;
}();

return module.exports;

});
define('actor',['require', 'exports', 'module', './node'], function (require, exports, module) {
  

var Actor, Node, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  };
Node = require("./node");
module.exports = Actor = function (_super) {
  __extends(Actor, _super);
  function Actor(game) {
    this.game = game;
    Actor.__super__.constructor.apply(this, arguments);
  }
  Actor.prototype.update = function (delta) {
  };
  Actor.prototype.draw = function (context) {
  };
  return Actor;
}(Node);

return module.exports;

});
define('stage',['require','exports','module'],function (require, exports, module) {
  

var Stage;
module.exports = Stage = function () {
  function Stage(game) {
    this.game = game;
    this.actors = [];
  }
  Stage.prototype.addActor = function (actor) {
    return this.actors.push(actor);
  };
  Stage.prototype.removeActor = function (actor) {
    var index;
    index = this.actors.indexOf(actor);
    if (index >= 0) {
      return this.actors.splice(index, 1);
    }
  };
  Stage.prototype.update = function (delta) {
    var actor, _i, _len, _ref, _results;
    _ref = this.actors;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      actor = _ref[_i];
      _results.push(actor.update(delta));
    }
    return _results;
  };
  Stage.prototype.draw = function (context) {
    var actor, _i, _len, _ref, _results;
    _ref = this.actors;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      actor = _ref[_i];
      _results.push(actor.draw(context));
    }
    return _results;
  };
  return Stage;
}();

return module.exports;

});
define('graphics/sprite',['require', 'exports', 'module', '../math/vector2', '../node'], function (require, exports, module) {
  

var Node, Sprite, Vector2, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  };
Vector2 = require("../math/vector2");
Node = require("../node");
module.exports = Sprite = function (_super) {
  __extends(Sprite, _super);
  Sprite.renderOffset = new Vector2(0, 0);
  function Sprite(textureAtlas, frame) {
    this.textureAtlas = textureAtlas;
    this.frame = frame;
    Sprite.__super__.constructor.apply(this, arguments);
    this.rotation = 0;
  }
  Sprite.prototype.getWidth = function () {
    return this.frame.frame.w * this.scale.x;
  };
  Sprite.prototype.getHeight = function () {
    return this.frame.frame.h * this.scale.y;
  };
  Sprite.prototype.getRotation = function () {
    return this.rotation;
  };
  Sprite.prototype.setRotation = function (rotation) {
    return this.rotation = rotation;
  };
  Sprite.prototype.draw = function (context, drawX, drawY, mirroredX, mirroredY) {
    var dh, dw, image, scaleX, scaleY, sh, sw, sx, sy, translateX, translateY, tx, ty;
    if (mirroredX == null) {
      mirroredX = false;
    }
    if (mirroredY == null) {
      mirroredY = false;
    }
    image = this.textureAtlas.getAtlasImage();
    sx = this.frame.frame.x;
    sy = this.frame.frame.y;
    sw = this.frame.frame.w;
    sh = this.frame.frame.h;
    dw = this.frame.frame.w * this.scale.x;
    dh = this.frame.frame.h * this.scale.y;
    context.save();
    tx = Math.round((drawX || this.position.x) + this.origin.x + Sprite.renderOffset.x);
    ty = Math.round((drawY || this.position.y) + this.origin.y + Sprite.renderOffset.y);
    if (mirrored) {
      scaleX = mirroredX ? -1 : 1;
      scaleY = mirroredY ? -1 : 1;
      translateX = mirroredX ? tx + dw : tx;
      translateY = mirroredY ? ty + dh : ty;
      context.translate(translateX, translateY);
      context.scale(scaleX, scaleY);
    } else {
      context.translate(tx, ty);
    }
    context.rotate(Math.PI / 180 * this.rotation);
    context.drawImage(image, sx, sy, sw, sh, -this.origin.x, -this.origin.y, dw, dh);
    return context.restore();
  };
  return Sprite;
}(Node);

return module.exports;

});
define('graphics/animsprite',['require', 'exports', 'module', '../math/vector2', './sprite'], function (require, exports, module) {
  

var AnimSprite, Sprite, Vector2, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  };
Vector2 = require("../math/vector2");
Sprite = require("./sprite");
module.exports = AnimSprite = function (_super) {
  __extends(AnimSprite, _super);
  function AnimSprite(textureAtlas, frame, spriteCount, animationInterval) {
    this.textureAtlas = textureAtlas;
    this.frame = frame;
    this.spriteCount = spriteCount;
    this.animationInterval = animationInterval;
    AnimSprite.__super__.constructor.apply(this, arguments);
    this.rotation = 0;
    this.sumDelta = 0;
    this.spriteIndex = 0;
  }
  AnimSprite.prototype.getWidth = function () {
    return this.frame.frame.w * this.scale.x;
  };
  AnimSprite.prototype.getHeight = function () {
    return this.frame.frame.h * this.scale.y;
  };
  AnimSprite.prototype.getRotation = function () {
    return this.rotation;
  };
  AnimSprite.prototype.setRotation = function (rotation) {
    return this.rotation = rotation;
  };
  AnimSprite.prototype.update = function (delta) {
    if (this.sumDelta >= this.animationInterval) {
      this.spriteIndex++;
      if (this.spriteIndex > this.spriteCount - 1) {
        this.spriteIndex = 0;
      }
      this.sumDelta -= this.animationInterval;
    }
    return this.sumDelta += delta;
  };
  AnimSprite.prototype.draw = function (context, drawX, drawY, mirrored) {
    var dh, dw, image, sh, sw, sx, sy, tx, ty, widthPerSprite;
    if (mirrored == null) {
      mirrored = false;
    }
    image = this.textureAtlas.getAtlasImage();
    widthPerSprite = Math.floor(this.frame.frame.w / this.spriteCount);
    sx = this.frame.frame.x;
    sy = this.frame.frame.y;
    sw = widthPerSprite;
    sh = this.frame.frame.h;
    sx += widthPerSprite * this.spriteIndex;
    dw = widthPerSprite * this.scale.x;
    dh = this.frame.frame.h * this.scale.y;
    context.save();
    tx = (drawX | this.position.x) + this.origin.x + Sprite.renderOffset.x;
    ty = (drawY | this.position.y) + this.origin.y + Sprite.renderOffset.y;
    if (mirrored) {
      context.translate(tx + dw, ty);
      context.scale(-1, 1);
    } else {
      context.translate(tx, ty);
    }
    context.rotate(Math.PI / 180 * this.rotation);
    context.drawImage(image, sx, sy, sw, sh, -this.origin.x, -this.origin.y, dw, dh);
    return context.restore();
  };
  return AnimSprite;
}(Sprite);

return module.exports;

});
define('graphics/textureregion',['require', 'exports', 'module', '../math/vector2'], function (require, exports, module) {
  

var TextureRegion, Vector2;
Vector2 = require("../math/vector2");
module.exports = TextureRegion = function () {
  function TextureRegion(atlas, frame) {
    this.atlas = atlas;
    this.frame = frame;
    this.image = this.atlas.getAtlasImage();
  }
  TextureRegion.prototype.draw = function (context, sx, sy, sw, sh, dx, dy) {
    var dh, dw, finalsx, finalsy;
    finalsx = this.frame.frame.x + sx;
    finalsy = this.frame.frame.y + sy;
    sw = Math.min(sw, this.frame.spriteSourceSize.w + this.frame.frame.x - (this.frame.frame.x + sx));
    sh = Math.min(sh, this.frame.spriteSourceSize.h + this.frame.frame.y - (this.frame.frame.y + sy));
    dw = sw;
    dh = sh;
    if (sw === 0 || sh === 0) {
      return;
    }
    return context.drawImage(this.image, finalsx, finalsy, sw, sh, dx, dy, dw, dh);
  };
  return TextureRegion;
}();

return module.exports;

});
define('graphics/textureatlas',['require', 'exports', 'module', './sprite', './animsprite', './textureregion'], function (require, exports, module) {
  

var AnimSprite, Sprite, TextureAtlas, TextureRegion;
Sprite = require("./sprite");
AnimSprite = require("./animsprite");
TextureRegion = require("./textureregion");
module.exports = TextureAtlas = function () {
  function TextureAtlas(frames, image) {
    this.frames = frames;
    this.image = image;
    return;
  }
  TextureAtlas.prototype.createSprite = function (filename) {
    var sprite;
    if (this.frames[filename] == null) {
      throw new Error("The sprite " + filename + " could not be found.");
    }
    sprite = new Sprite(this, this.frames[filename]);
    return sprite;
  };
  TextureAtlas.prototype.createAnimSprite = function (filename, spriteCount, animationInterval) {
    var sprite;
    if (this.frames[filename] == null) {
      throw new Error("The sprite " + filename + " could not be found.");
    }
    sprite = new AnimSprite(this, this.frames[filename], spriteCount, animationInterval);
    return sprite;
  };
  TextureAtlas.prototype.findRegion = function (filename) {
    var region;
    if (this.frames[filename] == null) {
      throw new Error("The region " + filename + " could not be found.");
    }
    region = new TextureRegion(this, this.frames[filename]);
    return region;
  };
  TextureAtlas.prototype.getAtlasImage = function () {
    return this.image;
  };
  return TextureAtlas;
}();

return module.exports;

});
define('graphics/bitmapfont',['require', 'exports', 'module', '../math/rectangle'], function (require, exports, module) {
  

var BitmapFont, Rectangle;
Rectangle = require("../math/rectangle");
BitmapFont = function () {
  function BitmapFont(fontFile, textureRegion) {
    this.fontFile = fontFile;
    this.textureRegion = textureRegion;
    this.chars = {};
    this.parseFontFile();
  }
  BitmapFont.prototype.parseFontFile = function () {
    var char, key, line, parameter, split, val, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
    _ref = this.fontFile.split("\n");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      split = line.split(" ");
      if (split[0] === "char") {
        char = {};
        _ref1 = split.slice(1, -1);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          parameter = _ref1[_j];
          _ref2 = parameter.split("="), key = _ref2[0], val = _ref2[1];
          char[key] = parseInt(val);
        }
        _results.push(this.chars[char.id] = char);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
  BitmapFont.prototype.getBounds = function (text) {
    var char, charCode, character, height, i, width, _i, _ref;
    width = 0;
    height = 0;
    for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      character = text.substr(i, 1);
      charCode = character.charCodeAt(0);
      if (this.chars[charCode] == null) {
        continue;
      }
      char = this.chars[charCode];
      width += char.xadvance;
      height = char.height;
    }
    return new Rectangle(0, 0, width, height);
  };
  BitmapFont.prototype.drawText = function (context, text, x, y) {
    var char, charCode, character, i, xOffset, _i, _ref, _results;
    xOffset = 0;
    _results = [];
    for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      character = text.substr(i, 1);
      charCode = character.charCodeAt(0);
      if (this.chars[charCode] == null) {
        continue;
      }
      char = this.chars[charCode];
      this.textureRegion.draw(context, char.x, char.y, char.width, char.height, x + xOffset + char.xoffset || 0, y + char.yoffset || 0);
      _results.push(xOffset += char.xadvance);
    }
    return _results;
  };
  return BitmapFont;
}();
module.exports = BitmapFont;

return module.exports;

});
define('graphics/tilemap',['require', 'exports', 'module', '../math/vector2', '../node', '../actor'], function (require, exports, module) {
  

var Actor, Node, TileMap, Vector2;
Vector2 = require("../math/vector2");
Node = require("../node");
Actor = require("../actor");
module.exports = TileMap = function () {
  function TileMap(game, tilesJson, image) {
    var layer, newLayer, _i, _len, _ref;
    this.game = game;
    this.image = image;
    this.tileWidth = tilesJson["tileheight"];
    this.tileHeight = tilesJson["tilewidth"];
    this.tileSpacing = tilesJson["tilesets"][0]["spacing"];
    this.layers = [];
    _ref = tilesJson["layers"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      layer = _ref[_i];
      newLayer = layer["data"];
      newLayer.width = layer["width"];
      newLayer.height = layer["height"];
      newLayer.scrollX = 0;
      newLayer.scrollY = 0;
      this.layers.push(newLayer);
    }
    this.numTilesOnTileSetX = (this.image.width - this.tileSpacing) / (this.tileWidth + this.tileSpacing);
  }
  TileMap.prototype.setScrollX = function (scrollX) {
    var layer, _i, _len, _ref, _results;
    _ref = this.layers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      layer = _ref[_i];
      _results.push(layer.scrollX = scrollX);
    }
    return _results;
  };
  TileMap.prototype.setScrollY = function (scrollY) {
    var layer, _i, _len, _ref, _results;
    _ref = this.layers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      layer = _ref[_i];
      _results.push(layer.scrollY = scrollY);
    }
    return _results;
  };
  TileMap.prototype.setScrollX = function (layerIndex, scrollX) {
    return this.layers[layerIndex].scrollX = scrollX;
  };
  TileMap.prototype.setScrollY = function (layerIndex, scrollY) {
    return this.layers[layerIndex].scrollY = scrollY;
  };
  TileMap.prototype.getScrollX = function (layerIndex) {
    return this.layers[layerIndex].scrollX;
  };
  TileMap.prototype.getScrollY = function (layerIndex) {
    return this.layers[layerIndex].scrollY;
  };
  TileMap.prototype.draw = function (context) {
    var dh, dw, index, indexOffsetX, indexOffsetY, layer, sh, softOffsetX, softOffsetY, sw, sx, sy, tileNumber, visibleTilesX, visibleTilesY, x, y, _i, _len, _ref, _results;
    _ref = this.layers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      layer = _ref[_i];
      visibleTilesX = Math.ceil(this.game.getWidth() / this.tileWidth);
      visibleTilesY = Math.ceil(this.game.getHeight() / this.tileHeight);
      sw = this.tileWidth;
      sh = this.tileHeight;
      dw = this.tileWidth;
      dh = this.tileHeight;
      indexOffsetX = Math.floor(layer.scrollX / this.tileWidth);
      indexOffsetY = Math.floor(layer.scrollY / this.tileHeight);
      softOffsetX = layer.scrollX % this.tileWidth;
      softOffsetY = layer.scrollY % this.tileHeight;
      if (this.image != null) {
        _results.push(function () {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; 0 <= visibleTilesY ? _j <= visibleTilesY : _j >= visibleTilesY; y = 0 <= visibleTilesY ? ++_j : --_j) {
            _results1.push(function () {
              var _k, _results2;
              _results2 = [];
              for (x = _k = 0; 0 <= visibleTilesX ? _k <= visibleTilesX : _k >= visibleTilesX; x = 0 <= visibleTilesX ? ++_k : --_k) {
                index = x + indexOffsetX + (y + indexOffsetY) * layer.width;
                tileNumber = layer[index] - 1;
                sx = this.tileSpacing + (this.tileWidth + this.tileSpacing) * (tileNumber % this.numTilesOnTileSetX);
                sy = this.tileSpacing + (this.tileHeight + this.tileSpacing) * Math.floor(tileNumber / this.numTilesOnTileSetX);
                _results2.push(context.drawImage(this.image, sx, sy, sw, sh, x * dw - softOffsetX, y * dh - softOffsetY, dw, dh));
              }
              return _results2;
            }.call(this));
          }
          return _results1;
        }.call(this));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
  return TileMap;
}();

return module.exports;

});
define('utilities/eventemitter',['require','exports','module'],function (require, exports, module) {
  

var EventEmitter, __slice = [].slice;
module.exports = EventEmitter = function () {
  function EventEmitter() {
  }
  EventEmitter.prototype.emit = function () {
    var args, event, listener, _i, _len, _ref;
    event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (this.events == null) {
      this.events = {};
    }
    if (!this.events[event]) {
      return false;
    }
    _ref = this.events[event];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      listener.apply(null, args);
    }
    return true;
  };
  EventEmitter.prototype.bind = function (event, listener) {
    var _base;
    if (this.events == null) {
      this.events = {};
    }
    ((_base = this.events)[event] != null ? (_base = this.events)[event] : _base[event] = []).push(listener);
    return this;
  };
  EventEmitter.prototype.once = function (event, listener) {
    var fn, _this = this;
    fn = function () {
      _this.unbind(event, fn);
      return listener.apply(null, arguments);
    };
    this.on(event, fn);
    return this;
  };
  EventEmitter.prototype.unbind = function (event, listener) {
    var l;
    if (this.events == null) {
      this.events = {};
    }
    if (!this.events[event]) {
      return this;
    }
    this.events[event] = function () {
      var _i, _len, _ref, _results;
      _ref = this.events[event];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        if (l !== listener) {
          _results.push(l);
        }
      }
      return _results;
    }.call(this);
    return this;
  };
  EventEmitter.prototype.unbindAll = function (event) {
    if (this.events == null) {
      this.events = {};
    }
    delete this.events[event];
    return this;
  };
  EventEmitter.prototype.on = EventEmitter.prototype.bind;
  EventEmitter.prototype.off = EventEmitter.prototype.unbind;
  EventEmitter.prototype.addListener = EventEmitter.prototype.bind;
  EventEmitter.prototype.removeListener = EventEmitter.prototype.unbind;
  return EventEmitter;
}();

return module.exports;

});
define('jquery',[],function () {
  if (__isNode) {
  return __nodeRequire('jquery');
} else {
  return (typeof $ !== 'undefined') ? $ : __nodeRequire('jquery')
}
});
define('utilities/preloader',['require', 'exports', 'module', './eventemitter', 'jquery'], function (require, exports, module) {
  

var $, EventEmitter, Preloader, __bind = function (fn, me) {
    return function () {
      return fn.apply(me, arguments);
    };
  }, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  };
EventEmitter = require("./eventemitter");
$ = require("jquery");
module.exports = Preloader = function (_super) {
  __extends(Preloader, _super);
  function Preloader(app, itemFilenames) {
    this.app = app;
    this.itemFilenames = itemFilenames;
    this.loadJPEG = __bind(this.loadJPEG, this);
    this.loadJPG = __bind(this.loadJPG, this);
    this.loadPNG = __bind(this.loadPNG, this);
    this.loadItem = __bind(this.loadItem, this);
    this.items = {};
  }
  Preloader.prototype.load = function () {
    var file, loadedItems, totalItems, _i, _len, _ref, _results, _this = this;
    loadedItems = 0;
    totalItems = this.itemFilenames.length;
    _ref = this.itemFilenames;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      _results.push(this.loadItem(file, function (err, item) {
        if (err != null) {
          return _this.emit("error", err);
        }
        _this.items[item.filename] = item.item;
        loadedItems++;
        if (loadedItems === totalItems) {
          return _this.emit("done");
        }
      }));
    }
    return _results;
  };
  Preloader.prototype.get = function (filename) {
    if (this.items[filename] == null) {
      throw new Error("The file " + filename + " has not been preloaded!");
    }
    return this.items[filename];
  };
  Preloader.prototype.loadItem = function (filename, callback) {
    var extension, loadingMethod;
    extension = filename.split(".").pop();
    loadingMethod = this["load" + extension.toUpperCase()];
    if (loadingMethod == null) {
      throw new Error("No loading method for " + filename);
    }
    return loadingMethod(filename, callback);
  };
  Preloader.prototype.loadJSON = function (filename, callback) {
    return $.getJSON(filename, function (data) {
      return callback(null, {
        filename: filename,
        item: data
      });
    });
  };
  Preloader.prototype.loadFNT = function (filename, callback) {
    return $.get(filename, function (data) {
      return callback(null, {
        filename: filename,
        item: data
      });
    });
  };
  Preloader.prototype.loadImage = function (filename, callback) {
    var image;
    image = new Image();
    image.onload = function () {
      return callback(null, {
        filename: filename,
        item: image
      });
    };
    return image.src = filename;
  };
  Preloader.prototype.loadPNG = function () {
    return this.loadImage.apply(this, arguments);
  };
  Preloader.prototype.loadJPG = function () {
    return this.loadImage.apply(this, arguments);
  };
  Preloader.prototype.loadJPEG = function () {
    return this.loadImage.apply(this, arguments);
  };
  return Preloader;
}(EventEmitter);

return module.exports;

});
define('utilities/keyboard',['require', 'exports', 'module', './eventemitter'], function (require, exports, module) {
  

var EventEmitter, Keyboard, __bind = function (fn, me) {
    return function () {
      return fn.apply(me, arguments);
    };
  }, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  };
EventEmitter = require("./eventemitter");
module.exports = Keyboard = function (_super) {
  __extends(Keyboard, _super);
  Keyboard.prototype.Keys = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    NUMPAD0: 96,
    NUMPAD1: 97,
    NUMPAD2: 98,
    NUMPAD3: 99,
    NUMPAD4: 100,
    NUMPAD5: 101,
    NUMPAD6: 102,
    NUMPAD7: 103,
    NUMPAD8: 104,
    NUMPAD9: 105,
    ASTERISK: 106,
    PLUS: 107,
    MINUS: 109,
    DOT: 110,
    SLASH: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    SHIFT: 16,
    SPACE: 32,
    ENTER: 13,
    ESC: 27
  };
  function Keyboard() {
    this._onKeyUp = __bind(this._onKeyUp, this);
    this._onKeyDown = __bind(this._onKeyDown, this);
    var key, keyCode, _ref;
    this.keyStates = [];
    _ref = this.Keys;
    for (key in _ref) {
      keyCode = _ref[key];
      this.keyStates[keyCode] = false;
    }
    $(window).keydown(this._onKeyDown);
    $(window).keyup(this._onKeyUp);
  }
  Keyboard.prototype._onKeyDown = function (e) {
    var keyCode, _ref;
    if ((_ref = e.keyCode) === this.Keys.UP || _ref === this.Keys.RIGHT || _ref === this.Keys.DOWN || _ref === this.Keys.LEFT || _ref === this.Keys.SPACE) {
      e.preventDefault();
    }
    this.emit("keydown", e);
    keyCode = e.keyCode;
    if (this.keyStates[keyCode] != null) {
      return this.keyStates[keyCode] = true;
    }
  };
  Keyboard.prototype._onKeyUp = function (e) {
    var keyCode;
    keyCode = e.keyCode;
    if (this.keyStates[keyCode] != null) {
      return this.keyStates[keyCode] = false;
    }
  };
  Keyboard.prototype.pressed = function (keyCode) {
    return this.keyStates[keyCode] || false;
  };
  Keyboard.prototype.upPressed = function () {
    return this.keyStates[this.Keys.UP] || this.keyStates[this.Keys.W] || this.keyStates[this.Keys.SPACE];
  };
  Keyboard.prototype.leftPressed = function () {
    return this.keyStates[this.Keys.DOWN] || this.keyStates[this.Keys.S];
  };
  Keyboard.prototype.leftPressed = function () {
    return this.keyStates[this.Keys.LEFT] || this.keyStates[this.Keys.A];
  };
  Keyboard.prototype.rightPressed = function () {
    return this.keyStates[this.Keys.RIGHT] || this.keyStates[this.Keys.D];
  };
  return Keyboard;
}(EventEmitter);

return module.exports;

});
define('ldfw',['require', 'exports', 'module', './game', './screen', './actor', './stage', './node', './graphics/textureatlas', './graphics/textureregion', './graphics/sprite', './graphics/bitmapfont', './graphics/tilemap', './math/vector2', './math/rectangle', './utilities/preloader', './utilities/keyboard'], function (require, exports, module) {
  

var LDFW, extend, mod, _i, _len, _ref;
LDFW = {
  Game: require("./game"),
  Screen: require("./screen"),
  Actor: require("./actor"),
  Stage: require("./stage"),
  Node: require("./node"),
  TextureAtlas: require("./graphics/textureatlas"),
  TextureRegion: require("./graphics/textureregion"),
  Sprite: require("./graphics/sprite"),
  BitmapFont: require("./graphics/bitmapfont"),
  TileMap: require("./graphics/tilemap"),
  Vector2: require("./math/vector2"),
  Rectangle: require("./math/rectangle"),
  Preloader: require("./utilities/preloader"),
  Keyboard: require("./utilities/keyboard")
};
extend = function (prototypeProperties) {
  var Surrogate, child, name, parent, prop;
  parent = this;
  child = function () {
    return parent.apply(this, arguments);
  };
  for (name in parent) {
    prop = parent[name];
    child[name] = prop;
  }
  Surrogate = function () {
    this.constructor = child;
  };
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate();
  for (name in prototypeProperties) {
    prop = prototypeProperties[name];
    child.prototype[name] = prop;
  }
  return child;
};
_ref = [
  "Game",
  "Screen",
  "Actor",
  "Stage",
  "Node"
];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  mod = _ref[_i];
  LDFW[mod].extend = extend;
}
module.exports = LDFW;

return module.exports;

});    return require('ldfw');
  };
if (__isAMD) {
  return define(['jquery'], bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory(require('jquery'));
    } else {
        return bundleFactory((typeof $ !== 'undefined') ? $ : void 0);
    }
}
}).call(this, (typeof exports === 'object' ? global : window),
              (typeof exports === 'object' ? global : window))